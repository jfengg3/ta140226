import csv from 'csv-parser';
import { Readable } from 'stream';
import { Post, CSVRow, ParseResult, ValidationError } from '../types';
import { validateCSVRow, sanitizeString } from './validation';

export function parseCSV(fileBuffer: Buffer): Promise<ParseResult> {
  return new Promise((resolve, reject) => {
    const validRows: Post[] = [];
    const errors: ValidationError[] = [];
    let rowNumber = 0; // Track which row we're on (for error messages)

    const stream = Readable.from(fileBuffer);

    stream
      .pipe(
        csv({
          // Map CSV headers to our expected field names
          // Remove quotes and trim whitespace from headers
          // Also handles BOM (Byte Order Mark) at the start
          mapHeaders: ({ header }) => {
            return header
              .replace(/^["\uFEFF]+|["\uFEFF]+$/g, '') // Remove quotes and BOM
              .trim();
          },
          skipLines: 0,
        })
      )
      .on('data', (row: CSVRow) => {
        rowNumber++;

        // Validate the row
        const rowErrors = validateCSVRow(row, rowNumber);

        if (rowErrors.length > 0) {
          // Row has errors - add to errors array
          errors.push({
            row: rowNumber,
            reason: rowErrors.join(', '),
          });
        } else {
          // Row is valid - convert to Post object
          const post: Post = {
            id: 0, // Will be auto-generated by database
            postId: parseInt(row.postId),
            commentId: parseInt(row.id),
            name: sanitizeString(row.name),
            email: row.email.trim().toLowerCase(),
            body: sanitizeString(row.body),
            createdAt: new Date(),
          };
          validRows.push(post);
        }
      })
      .on('end', () => {
        // Parsing complete
        resolve({
          validRows,
          errors,
        });
      })
      .on('error', (error) => {
        // CSV parsing failed (malformed CSV)
        reject(new Error(`CSV parsing failed: ${error.message}`));
      });
  });
}

export function validateHeaders(headers: string[]): boolean {
  const requiredHeaders = ['postId', 'id', 'name', 'email', 'body'];
  const normalizedHeaders = headers.map((h) => h.trim());

  // Check all required headers are present
  return requiredHeaders.every((required) =>
    normalizedHeaders.includes(required)
  );
}
